# Feature 4 — Employee Skill Management

## Overview
Feature 4 implements comprehensive skill management for employees, allowing HR staff to track, add, and remove skills from employee profiles.

## Two Implementation Approaches

The system now supports **both** approaches simultaneously:

### 1. JSONField Approach (Original - `current_skills`)
- **Field**: `Employee.current_skills` (JSONField)
- **Storage**: Skills stored as list of strings `["Python", "Django", "React"]`
- **Pros**:
  - Simple and flexible
  - No additional database tables
  - Easy to query and display
  - Good for prototyping

### 2. ManyToMany Approach (Advanced - `skills`)
- **Field**: `Employee.skills` (ManyToManyField)
- **Storage**: Normalized relationship with intermediate table
- **Pros**:
  - Proper database normalization
  - Foreign key constraints ensure data integrity
  - Better for complex queries (e.g., "all employees with skill X")
  - Automatic cascade deletion handling
  - Can add metadata to relationship later (proficiency level, date acquired, etc.)

## API Endpoints

All three endpoints work with the ManyToMany approach:

### Add Skill to Employee
```http
POST /api/employees/{id}/add-skill/
Content-Type: application/json

{
  "skill_id": 5
}
```

**Response:**
```json
{
  "message": "Skill \"Python\" added successfully",
  "skills": ["Python", "Django"]
}
```

### Remove Skill from Employee
```http
POST /api/employees/{id}/remove-skill/
Content-Type: application/json

{
  "skill_id": 5
}
```

**Response:**
```json
{
  "message": "Skill \"Python\" removed successfully",
  "skills": ["Django"]
}
```

### Update All Employee Skills
```http
PUT /api/employees/{id}/skills/
Content-Type: application/json

{
  "skill_ids": [1, 2, 3]
}
```

**Response:**
```json
{
  "message": "Skills updated successfully",
  "skills": ["Python", "Django", "React"]
}
```

## Implementation Details

### Models (Section 4.5)
```python
class Employee(models.Model):
    # ... existing fields ...
    
    # Option A: JSONField (simple)
    current_skills = models.JSONField(
        default=list,
        blank=True,
        help_text="Liste des compétences actuelles de l'employé"
    )
    
    # Option B: ManyToMany (advanced, normalized)
    skills = models.ManyToManyField(
        Skill,
        blank=True,
        related_name='employees',
        help_text="Skills possessed by this employee"
    )
```

### ViewSet Actions (Sections 4.2 & 4.5)

#### Add Skill
```python
@action(detail=True, methods=['post'], url_path='add-skill')
def add_skill(self, request, pk=None):
    employee = self.get_object()
    skill = Skill.objects.get(pk=skill_id)
    
    if skill not in employee.skills.all():
        employee.skills.add(skill)  # ManyToMany method
    
    return Response({
        'message': f'Skill "{skill.name}" added successfully',
        'skills': [s.name for s in employee.skills.all()]
    })
```

#### Remove Skill
```python
@action(detail=True, methods=['post'], url_path='remove-skill')
def remove_skill(self, request, pk=None):
    employee = self.get_object()
    skill = Skill.objects.get(pk=skill_id)
    
    if skill in employee.skills.all():
        employee.skills.remove(skill)  # ManyToMany method
    
    return Response({
        'message': f'Skill "{skill.name}" removed successfully',
        'skills': [s.name for s in employee.skills.all()]
    })
```

#### Update Skills
```python
@action(detail=True, methods=['put'], url_path='skills')
def update_skills(self, request, pk=None):
    employee = self.get_object()
    skill_ids = request.data.get('skill_ids', [])
    
    skills = Skill.objects.filter(id__in=skill_ids)
    employee.skills.set(skills)  # ManyToMany method (replaces all)
    
    return Response({
        'message': 'Skills updated successfully',
        'skills': [s.name for s in employee.skills.all()]
    })
```

## URL Routing (Section 4.3)

URLs are auto-generated by DRF's DefaultRouter:

```python
router.register(r"employees", EmployeeViewSet, basename="employee")
```

**Generated URL names:**
- `employee-list`: `/api/employees/`
- `employee-detail`: `/api/employees/{id}/`
- `employee-add-skill`: `/api/employees/{id}/add-skill/`
- `employee-remove-skill`: `/api/employees/{id}/remove-skill/`
- `employee-update-skills`: `/api/employees/{id}/skills/`

## Serializers (Section 4.1)

### AddSkillToEmployeeSerializer
```python
class AddSkillToEmployeeSerializer(serializers.Serializer):
    skill_id = serializers.IntegerField()

    def validate_skill_id(self, value):
        if not Skill.objects.filter(pk=value).exists():
            raise serializers.ValidationError("Skill not found")
        return value
```

### RemoveSkillFromEmployeeSerializer
```python
class RemoveSkillFromEmployeeSerializer(serializers.Serializer):
    skill_id = serializers.IntegerField()
```

### UpdateEmployeeSkillsSerializer
```python
class UpdateEmployeeSkillsSerializer(serializers.Serializer):
    current_skills = serializers.ListField(
        child=serializers.CharField(),
        allow_empty=True
    )
```

## Testing (Section 4.4)

```python
def test_skill_tracking_flow(admin_client, sample_employee, sample_skill):
    """Test tracking skill assignments using ManyToMany relationship."""
    # Add skill
    url = reverse('employee-add-skill', kwargs={'pk': sample_employee.id})
    data = {'skill_id': sample_skill.id}
    response = admin_client.post(url, data, format='json')
    
    assert response.status_code == 200
    assert sample_skill.name in response.data['skills']
    
    # Verify persistence
    sample_employee.refresh_from_db()
    assert sample_skill in sample_employee.skills.all()
    
    # Remove skill
    remove_url = reverse('employee-remove-skill', kwargs={'pk': sample_employee.id})
    remove_response = admin_client.post(remove_url, data, format='json')
    
    assert remove_response.status_code == 200
    assert sample_skill.name not in remove_response.data['skills']
```

## Migration (Section 4.5)

```bash
# Generate migration
python manage.py makemigrations

# Apply migration
python manage.py migrate
```

**Migration 0009_employee_skills:**
- Creates `future_skills_employee_skills` intermediate table
- Columns: `id`, `employee_id`, `skill_id`
- Indexes on both foreign keys

## Permissions

All skill management endpoints require:
- **Permission**: `IsHRStaffOrManager`
- **Authentication**: Required (token or session)

## Usage Examples

### Using Django ORM

```python
# Get all employees with Python skill
python_skill = Skill.objects.get(name="Python")
python_employees = python_skill.employees.all()

# Get all skills for an employee
employee = Employee.objects.get(id=1)
employee_skills = employee.skills.all()

# Add skill
employee.skills.add(python_skill)

# Remove skill
employee.skills.remove(python_skill)

# Replace all skills
new_skills = Skill.objects.filter(name__in=["Python", "Django"])
employee.skills.set(new_skills)

# Check if employee has skill
has_python = employee.skills.filter(name="Python").exists()
```

### Using REST API

```python
import requests

# Add skill
response = requests.post(
    'http://localhost:8000/api/employees/1/add-skill/',
    json={'skill_id': 5},
    headers={'Authorization': 'Token your-token-here'}
)

# Remove skill
response = requests.post(
    'http://localhost:8000/api/employees/1/remove-skill/',
    json={'skill_id': 5},
    headers={'Authorization': 'Token your-token-here'}
)

# Update all skills
response = requests.put(
    'http://localhost:8000/api/employees/1/skills/',
    json={'skill_ids': [1, 2, 3]},
    headers={'Authorization': 'Token your-token-here'}
)
```

## Recommendations

### When to use JSONField (`current_skills`)
- Simple projects or prototypes
- When skills are just display labels
- No complex queries needed
- Maximum flexibility

### When to use ManyToMany (`skills`)
- Production applications
- Need data integrity constraints
- Complex queries (e.g., "find all employees with skill X")
- Want to add metadata later (proficiency, certification date)
- Multiple features depend on skill relationships

## Future Enhancements

The ManyToMany relationship can be extended with a through model:

```python
class EmployeeSkill(models.Model):
    employee = models.ForeignKey(Employee, on_delete=models.CASCADE)
    skill = models.ForeignKey(Skill, on_delete=models.CASCADE)
    
    # Metadata
    proficiency_level = models.CharField(max_length=20)  # Beginner, Intermediate, Advanced
    acquired_date = models.DateField()
    certification = models.CharField(max_length=200, blank=True)
    years_experience = models.FloatField()
    
    class Meta:
        unique_together = ('employee', 'skill')
```

Then update the model:
```python
class Employee(models.Model):
    skills = models.ManyToManyField(
        Skill,
        through='EmployeeSkill',
        related_name='employees'
    )
```

## Commits

- **6fda5aa**: Sections 4.1 & 4.2 (Serializers + ViewSet Actions)
- **8674b53**: Section 4.4 (Test Implementation)
- **2c108ab**: Section 4.5 (ManyToMany Relationship)
